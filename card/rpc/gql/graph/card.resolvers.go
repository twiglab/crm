package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"fmt"
	"time"

	"github.com/twiglab/crm/card/orm/ent/card"
	"github.com/twiglab/crm/card/pkg/data"
	"github.com/twiglab/crm/poly/orm/ent"
)

// CreateCard is the resolver for the createCard field.
func (r *mutationResolver) CreateCard(ctx context.Context, input data.CreateCardReq) (*data.CardResp, error) {
	if input.CardCode == nil {
		// TODO 生成code，临时使用时间戳代替
		cardCode := fmt.Sprintf("%d", time.Now().Nanosecond()/1e3)
		input.CardCode = &cardCode
	}

	// 指定code时，检查code是否已经存在
	q := r.Client.Card.Query()
	q.Where(card.CardCodeEQ(*input.CardCode))
	b, err := q.Exist(ctx)
	if err != nil {
		return nil, err
	}
	if b {
		return nil, fmt.Errorf("card code already exist")
	}

	c := r.Client.Card.Create()
	c.SetCardCode(*input.CardCode)
	c.SetAmount(input.Balance)
	c.SetBalance(input.Balance)
	c.SetType(input.Type)
	cobj, err := c.Save(ctx)
	if err != nil {
		return nil, err
	}

	return &data.CardResp{
		Code:       cobj.Code,
		CardCode:   cobj.CardCode,
		MemberCode: &cobj.MemberCode,
		Type:       cobj.Type,
		Balance:    cobj.Balance,
		Amount:     cobj.Amount,
	}, nil
}

// BindCard is the resolver for the bindCard field.
func (r *mutationResolver) BindCard(ctx context.Context, input data.BindCardReq) (*data.CardResp, error) {
	q, err := r.Client.Card.Query().Where(card.CodeEQ(input.Code)).First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("card code not found")
		}
		return nil, err
	}
	if q.MemberCode != "" {
		return nil, fmt.Errorf("card already binded")
	}

	c := r.Client.Card.UpdateOne(q)
	c.SetMemberCode(input.MemberCode)
	cobj, err := c.Save(ctx)
	if err != nil {
		return nil, err
	}

	return &data.CardResp{
		Code:       cobj.Code,
		CardCode:   cobj.CardCode,
		MemberCode: &cobj.MemberCode,
		Type:       cobj.Type,
		Balance:    cobj.Balance,
		Amount:     cobj.Amount,
	}, nil
}

// QueryCardDetail is the resolver for the queryCardDetail field.
func (r *queryResolver) QueryCardDetail(ctx context.Context, input *data.QueryCardByCode) (*data.CardResp, error) {
	cobj, err := r.Client.Card.Query().Where(card.CodeEQ(input.Code)).First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("card code not found")
		}
		return nil, err
	}

	return &data.CardResp{
		Code:       cobj.Code,
		CardCode:   cobj.CardCode,
		MemberCode: &cobj.MemberCode,
		Type:       cobj.Type,
		Balance:    cobj.Balance,
		Amount:     cobj.Amount,
	}, nil
}

// QueryCardList is the resolver for the queryCardList field.
func (r *queryResolver) QueryCardList(ctx context.Context, input *data.PaginationReq) ([]*data.CardResp, error) {
	q := r.Client.Card.Query()
	// q.Where(card.)
	if input.Order != nil && *input.Order == "desc" {
		q.Order(ent.Desc(card.FieldCode)).Where(card.CodeGT(*input.Cursor))
	} else {
		q.Order(ent.Asc(card.FieldCode)).Where(card.CodeLT(*input.Cursor))
	}
	if input.Limit != nil {
		q.Limit(*input.Limit)
	} else {
		q.Limit(10)
	}
	cobjs, err := q.All(ctx)
	if err != nil {
		return nil, err
	}

	var rets []*data.CardResp
	for _, cobj := range cobjs {
		obj := &data.CardResp{
			Code:       cobj.Code,
			CardCode:   cobj.CardCode,
			MemberCode: &cobj.MemberCode,
			Type:       cobj.Type,
			Balance:    cobj.Balance,
			Amount:     cobj.Amount,
		}
		rets = append(rets, obj)
	}

	return rets, nil
}

// QueryCardByMemberCode is the resolver for the queryCardByMemberCode field.
func (r *queryResolver) QueryCardByMemberCode(ctx context.Context, input *data.QueryCardByMemberCode) ([]*data.CardResp, error) {
	q := r.Client.Card.Query()
	if input.PageInfo.Order != nil && *input.PageInfo.Order == "desc" {
		q.Order(ent.Desc(card.FieldCode)).Where(card.CodeGT(*input.PageInfo.Cursor))
	} else {
		q.Order(ent.Asc(card.FieldCode)).Where(card.CodeLT(*input.PageInfo.Cursor))
	}
	q.Where(card.MemberCodeEQ(input.MemberCode))
	if input.PageInfo.Limit != nil {
		q.Limit(*input.PageInfo.Limit)
	} else {
		q.Limit(10)
	}
	cobjs, err := q.All(ctx)
	if err != nil {
		return nil, err
	}

	var rets []*data.CardResp
	for _, cobj := range cobjs {
		obj := &data.CardResp{
			Code:       cobj.Code,
			CardCode:   cobj.CardCode,
			MemberCode: &cobj.MemberCode,
			Type:       cobj.Type,
			Balance:    cobj.Balance,
			Amount:     cobj.Amount,
		}
		rets = append(rets, obj)
	}
	return rets, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
